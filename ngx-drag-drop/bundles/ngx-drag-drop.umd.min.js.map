{"version":3,"sources":["ng://ngx-drag-drop/dnd-utils.ts","ng://ngx-drag-drop/dnd-state.ts","ng://ngx-drag-drop/dnd-draggable.directive.ts","ng://ngx-drag-drop/dnd-dropzone.directive.ts","ng://ngx-drag-drop/dnd-handle.directive.ts","ng://ngx-drag-drop/dnd.module.ts"],"names":["DROP_EFFECTS","CUSTOM_MIME_TYPE","JSON_MIME_TYPE","MSIE_MIME_TYPE","mimeTypeIsCustom","mimeType","substr","length","getWellKnownMimeType","event","dataTransfer","types","i","filterEffects","effects","allowed","filter","effect","toLowerCase","indexOf","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","_dndState","isDragging","dropEffect","effectAllowed","type","undefined","endDrag","setDropEffect","getDropEffect","dataTransferEffectAllowed","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","parent","elementRef","registerDragImage","Directive","args","selector","DndDraggableDirective","ElementRef","renderer","ngZone","_this","this","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","EventEmitter","dndDrag","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","dragEventHandler","onDrag","Object","defineProperty","prototype","value","removeClass","nativeElement","addClass","dndDisableIf","ngAfterViewInit","runOutsideAngular","addEventListener","ngOnDestroy","removeEventListener","onDragStart","dndHandle","_dndUsingHandle","startDrag","dndType","setDragData","data","dataString","JSON","stringify","setData","e","effectsAllowed","getData","preTransferClipboardData","dndDraggable","determineDragImage","dndDragImageElementRef","setDragImage","offsetFunction","offset","unregister","listen","emit","stopPropagation","onDragEnd","dropEffectEmitter","setTimeout","registerDragHandle","handle","Renderer2","NgZone","Input","Output","HostBinding","HostListener","DndPlaceholderRefDirective","DndDropzoneDirective","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","dragEnterEventHandler","onDragEnter","dragOverEventHandler","onDragOver","dragLeaveEventHandler","onDragLeave","tryGetPlaceholder","removePlaceholderFromDOM","_dndDropzoneActive","newTarget","document","elementFromPoint","clientX","clientY","contains","isDropAllowed","preventDefault","cleanupDragoverState","defaultPrevented","checkAndUpdatePlaceholderPosition","onDrop","getDropData","dragIsExternal","parse","dropIndex","getPlaceholderIndex","isExternal","index","dndDropzone","Array","isArray","Error","dndPlaceholderRef","querySelector","parentNode","removeChild","appendChild","directChild","getDirectChildElement","parentElement","childElement","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","left","width","top","height","previousSibling","insertBefore","nextSibling","call","children","ContentChild","DndHandleDirective","onDragEvent","DndModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DragDropData {\n  data?:any;\n  type?:string;\n}\n\nexport interface DndEvent extends DragEvent {\n  _dndUsingHandle?:boolean;\n  _dndDropzoneActive?:true;\n}\n\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\n\nexport const DROP_EFFECTS = [ \"move\", \"copy\", \"link\" ] as DropEffect[];\n\nexport const CUSTOM_MIME_TYPE = \"application/x-dnd\";\nexport const JSON_MIME_TYPE = \"application/json\";\nexport const MSIE_MIME_TYPE = \"Text\";\n\nfunction mimeTypeIsCustom( mimeType:string ) {\n\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\n}\n\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\n\n  if( event.dataTransfer ) {\n\n    const types = event.dataTransfer.types;\n\n    // IE 9 workaround.\n    if( !types ) {\n\n      return MSIE_MIME_TYPE;\n    }\n\n    for( let i = 0; i < types.length; i++ ) {\n\n      if( types[ i ] === MSIE_MIME_TYPE\n        || types[ i ] === JSON_MIME_TYPE\n        || mimeTypeIsCustom( types[ i ] ) ) {\n\n        return types[ i ];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\n\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\n\n  const dataString = JSON.stringify( data );\n\n  try {\n\n    event.dataTransfer.setData( mimeType, dataString );\n\n  }\n  catch( e ) {\n\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\n\n    }\n    catch( e ) {\n\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\n      \n      /*\n      BUG FIX - ISSUE: in IE11 when dragging in a NEW Workflow Node the clipboard gets overwritten with the\n      node model JSON data when event.dataTransfer.setData() below is called.\n      this causes issues when a user has previously copied text to the clipboard with the idea of pasting it,\n      as the user's intended data to paste is overwritten just by doing an un-related action ie: simply dragging in a New Workflow Node.\n\n      BUG FIX: store the value of clipboard before event.dataTransfer.setData() is called and then restore the data to clipboard.\n    */\n    try {\n      if(window['clipboardData'] && window['clipboardData'].getData('Text') ){\n        var preTransferClipboardData = window['clipboardData'].getData('Text');\n      }\n    } catch(e){\n      //do nothing just swallow any clipboard related errors\n    }\n\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\n      \n    // clipboard data is restored here as part of BUG FIX referenced above\n    try {\n          if(window['clipboardData'] && preTransferClipboardData){\n          window['clipboardData'].setData('Text', preTransferClipboardData);\n          }\n        } catch(e){\n          //do nothing just swallow any clipboard related errors\n        }\n    }\n  }\n}\n\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\n\n  // check if the mime type is well known\n  const mimeType = getWellKnownMimeType( event );\n\n  // drag did not originate from [dndDraggable]\n  if( dragIsExternal === true ) {\n\n    if( mimeType !== null\n      && mimeTypeIsCustom( mimeType ) ) {\n\n      // the type of content is well known and safe to handle\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\n    }\n\n    // the contained data is unknown, let user handle it\n    return {};\n  }\n\n  // the type of content is well known and safe to handle\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\n}\n\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\n\n  if( allowed === \"all\"\n    || allowed === \"uninitialized\" ) {\n\n    return effects;\n  }\n\n  return effects.filter( function( effect ) {\n\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\n  } );\n}\n\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\n\n  let directChild:Node = childElement;\n\n  while( directChild.parentNode !== parentElement ) {\n\n    // reached root node without finding given parent\n    if( !directChild.parentNode ) {\n\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return directChild as Element;\n}\n\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\n\n  const bounds = element.getBoundingClientRect();\n\n  // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n  if( horizontal ) {\n\n    return (event.clientX < bounds.left + bounds.width / 2);\n  }\n\n  return (event.clientY < bounds.top + bounds.height / 2);\n}\n\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\n\n  const dragImageComputedStyle = window.getComputedStyle( dragImage );\n  const paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\n  const paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\n  const borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\n  const borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\n\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\n\n  const offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\n\n  (event.dataTransfer as any).setDragImage( dragImage, offset.x, offset.y );\n}\n","import {\n  CUSTOM_MIME_TYPE,\n  DROP_EFFECTS,\n  filterEffects,\n  getWellKnownMimeType,\n  JSON_MIME_TYPE,\n  MSIE_MIME_TYPE\n} from \"./dnd-utils\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndState {\n  isDragging:boolean;\n  dropEffect?:DropEffect;\n  effectAllowed?:EffectAllowed;\n  type?:string;\n}\n\nconst _dndState:DndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\n\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n\nexport function endDrag() {\n\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\n\n  if( _dndState.isDragging === true ) {\n\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\n\n  const dataTransferEffectAllowed:EffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed as EffectAllowed : \"uninitialized\";\n\n  let effects = filterEffects( DROP_EFFECTS, dataTransferEffectAllowed );\n\n  if( _dndState.isDragging === true ) {\n\n    effects = filterEffects( effects, _dndState.effectAllowed );\n  }\n\n  if( effectAllowed ) {\n\n    effects = filterEffects( effects, effectAllowed );\n  }\n\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n  if( effects.length === 0 ) {\n\n    return \"none\";\n  }\n\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\n\n    return \"copy\";\n  }\n\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\n\n    return \"link\";\n  }\n\n  return effects[ 0 ] as DropEffect;\n}\n\nexport function getDndType( event:DragEvent ):string | undefined {\n\n  if( _dndState.isDragging === true ) {\n\n    return _dndState.type;\n  }\n\n  const mimeType = getWellKnownMimeType( event );\n\n  if( mimeType === null ) {\n\n    return undefined;\n  }\n\n  if( mimeType === MSIE_MIME_TYPE\n    || mimeType === JSON_MIME_TYPE ) {\n\n    return undefined;\n  }\n\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\n}\n\nexport function isExternalDrag():boolean {\n\n  return _dndState.isDragging === false;\n}\n\nexport const dndState:Readonly<DndState> = _dndState as Readonly<DndState>;\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from \"./dnd-utils\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\nimport { dndState, endDrag, startDrag } from \"./dnd-state\";\nimport { EffectAllowed } from \"./dnd-types\";\n\n@Directive( {\n  selector: \"[dndDragImageRef]\"\n} )\nexport class DndDragImageRefDirective {\n\n  constructor( parent:DndDraggableDirective,\n               elementRef:ElementRef ) {\n\n    parent.registerDragImage( elementRef );\n  }\n}\n\n@Directive( {\n  selector: \"[dndDraggable]\"\n} )\nexport class DndDraggableDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDraggable:any;\n\n  @Input()\n  dndEffectAllowed:EffectAllowed = \"copy\";\n\n  @Input()\n  dndType?:string;\n\n  @Input()\n  dndDraggingClass = \"dndDragging\";\n\n  @Input()\n  dndDraggingSourceClass = \"dndDraggingSource\";\n\n  @Input()\n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\n\n  @Input()\n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\n\n  @Output()\n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrag:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  private dndHandle?:DndHandleDirective;\n\n  private dndDragImageElementRef?:ElementRef;\n\n  private dragImage:Element;\n\n  private isDragStarted:boolean = false;\n\n  private readonly dragEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDrag( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.draggable = !value;\n\n    if( this.draggable ) {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n    else {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDragIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private elementRef:ElementRef,\n               private renderer:Renderer2,\n               private ngZone:NgZone ) {\n  }\n\n  ngAfterViewInit():void {\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"drag\", this.dragEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"drag\", this.dragEventHandler );\n    if(this.isDragStarted === true) {\n      endDrag()\n    }\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  onDragStart( event:DndEvent ) {\n\n    if( this.draggable === false ) {\n\n      return false;\n    }\n\n    // check if there is dnd handle and if the dnd handle was used to start the drag\n    if( typeof this.dndHandle !== \"undefined\"\n      && typeof event._dndUsingHandle === \"undefined\" ) {\n\n      return false;\n    }\n\n    // initialize global state\n    startDrag( event, this.dndEffectAllowed, this.dndType );\n\n    this.isDragStarted = true;\n\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\n\n    this.dragImage = this.determineDragImage();\n\n    // set dragging css class prior to setDragImage so styles are applied before\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\n\n    // set custom dragimage if present\n    // set dragimage if drag is started from dndHandle\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\n\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\n    }\n\n    // add dragging source css class on first drag event\n    const unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n      unregister();\n    } );\n\n    this.dndStart.emit( event );\n\n    event.stopPropagation();\n  }\n\n  onDrag( event:DragEvent ) {\n\n    this.dndDrag.emit( event );\n  }\n\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEnd( event:DragEvent ) {\n\n    // get drop effect from custom stored state as its not reliable across browsers\n    const dropEffect = dndState.dropEffect;\n\n    let dropEffectEmitter:EventEmitter<DragEvent>;\n\n    switch( dropEffect ) {\n\n      case \"copy\":\n        dropEffectEmitter = this.dndCopied;\n        break;\n\n      case \"link\":\n        dropEffectEmitter = this.dndLinked;\n        break;\n\n      case \"move\":\n        dropEffectEmitter = this.dndMoved;\n        break;\n\n      default:\n        dropEffectEmitter = this.dndCanceled;\n        break;\n    }\n\n    dropEffectEmitter.emit( event );\n    this.dndEnd.emit( event );\n\n    // reset global state\n    endDrag();\n\n    this.isDragStarted = false;\n\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\n\n    // IE9 special hammering\n    window.setTimeout( () => {\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n    }, 0 );\n\n    event.stopPropagation();\n  }\n\n  registerDragHandle( handle:DndHandleDirective | undefined ) {\n\n    this.dndHandle = handle;\n  }\n\n  registerDragImage( elementRef:ElementRef | undefined ) {\n\n    this.dndDragImageElementRef = elementRef;\n  }\n\n  private determineDragImage():Element {\n\n    // evaluate custom drag image existence\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\n\n      return this.dndDragImageElementRef.nativeElement as Element;\n    }\n    else {\n\n      return this.elementRef.nativeElement;\n    }\n  }\n}\n","import {\n  AfterViewInit,\n  ContentChild,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport {\n  DndEvent,\n  DragDropData,\n  getDirectChildElement,\n  getDropData,\n  shouldPositionPlaceholderBeforeElement\n} from \"./dnd-utils\";\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from \"./dnd-state\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndDropEvent {\n  event:DragEvent;\n  dropEffect:DropEffect;\n  isExternal:boolean;\n  data?:any;\n  index?:number;\n  type?:any;\n}\n\n@Directive( {\n  selector: \"[dndPlaceholderRef]\"\n} )\nexport class DndPlaceholderRefDirective {\n\n  constructor( public readonly elementRef:ElementRef ) {\n  }\n}\n\n@Directive( {\n  selector: \"[dndDropzone]\"\n} )\nexport class DndDropzoneDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDropzone?:string[];\n\n  @Input()\n  dndEffectAllowed:EffectAllowed;\n\n  @Input()\n  dndAllowExternal:boolean = false;\n\n  @Input()\n  dndHorizontal:boolean = false;\n\n  @Input()\n  dndDragoverClass:string = \"dndDragover\";\n\n  @Input()\n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n\n  @Output()\n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\n\n  @ContentChild( DndPlaceholderRefDirective )\n  private readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\n\n  private placeholder:Element | null = null;\n\n  private disabled:boolean = false;\n\n  private readonly dragEnterEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragEnter( event );\n  private readonly dragOverEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragOver( event );\n  private readonly dragLeaveEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragLeave( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.disabled = !!value;\n\n    if( this.disabled ) {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n    else {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDropIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private ngZone:NgZone,\n               private elementRef:ElementRef,\n               private renderer:Renderer2 ) {\n  }\n\n  ngAfterViewInit():void {\n\n    this.placeholder = this.tryGetPlaceholder();\n\n    this.removePlaceholderFromDOM();\n\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"dragenter\", this.dragEnterEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragover\", this.dragOverEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragleave\", this.dragLeaveEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"dragenter\", this.dragEnterEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragover\", this.dragOverEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragleave\", this.dragLeaveEventHandler );\n  }\n\n  onDragEnter( event:DndEvent ) {\n\n    // check if another dropzone is activated\n    if( event._dndDropzoneActive === true ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // set as active if the target element is inside this dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n      }\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    // allow the dragenter\n    event.preventDefault();\n  }\n\n  onDragOver( event:DragEvent ) {\n    // With nested dropzones, we want to ignore this event if a child dropzone\n    // has already handled a dragover.  Historically, event.stopPropagation() was\n    // used to prevent this bubbling, but that prevents any dragovers outside the\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n    // Instead, we can check if the event was already prevented by a child and bail early.\n    if( event.defaultPrevented ) {\n\n      return;\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    this.checkAndUpdatePlaceholderPosition( event );\n\n    const dropEffect = getDropEffect( event, this.dndEffectAllowed );\n\n    if( dropEffect === \"none\" ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // allow the dragover\n    event.preventDefault();\n\n    // set the drop effect\n    setDropEffect( event, dropEffect );\n\n    this.dndDragover.emit( event );\n\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\n  }\n\n  @HostListener( \"drop\", [ \"$event\" ] )\n  onDrop( event:DragEvent ) {\n\n    try {\n\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType( event );\n      if( this.isDropAllowed( type ) === false ) {\n\n        return;\n      }\n\n      const data:DragDropData = getDropData( event, isExternalDrag() );\n\n      if( this.isDropAllowed( data.type ) === false ) {\n\n        return;\n      }\n\n      // signal custom drop handling\n      event.preventDefault();\n\n      const dropEffect = getDropEffect( event );\n\n      setDropEffect( event, dropEffect );\n\n      if( dropEffect === \"none\" ) {\n\n        return;\n      }\n\n      const dropIndex = this.getPlaceholderIndex();\n\n      // if for whatever reason the placeholder is not present in the DOM but it should be there\n      // we don't allow/emit the drop event since it breaks the contract\n      // seems to only happen if drag and drop is executed faster than the DOM updates\n      if( dropIndex === -1 ) {\n\n        return;\n      }\n\n      this.dndDrop.emit( {\n        event: event,\n        dropEffect: dropEffect,\n        isExternal: isExternalDrag(),\n        data: data.data,\n        index: dropIndex,\n        type: type,\n      } );\n\n      event.stopPropagation();\n\n    }\n    finally {\n\n      this.cleanupDragoverState();\n    }\n  }\n\n  onDragLeave( event:DndEvent ) {\n\n    // check if still inside this dropzone and not yet handled by another dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n        return;\n      }\n    }\n\n    this.cleanupDragoverState();\n\n    // cleanup drop effect when leaving dropzone\n    setDropEffect( event, \"none\" );\n  }\n\n  private isDropAllowed( type?:string ):boolean {\n\n    // dropzone is disabled -> deny it\n    if( this.disabled === true ) {\n\n      return false;\n    }\n\n    // if drag did not start from our directive\n    // and external drag sources are not allowed -> deny it\n    if( isExternalDrag() === true\n      && this.dndAllowExternal === false ) {\n\n      return false;\n    }\n\n    // no filtering by types -> allow it\n    if( !this.dndDropzone ) {\n\n      return true;\n    }\n\n    // no type set -> allow it\n    if( !type ) {\n\n      return true;\n    }\n\n    if( Array.isArray( this.dndDropzone ) === false ) {\n\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\n    }\n\n    // if dropzone contains type -> allow it\n    return this.dndDropzone.indexOf( type ) !== -1;\n  }\n\n  private tryGetPlaceholder():Element | null {\n\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\n\n      return this.dndPlaceholderRef.elementRef.nativeElement as Element;\n    }\n\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\n  }\n\n  private removePlaceholderFromDOM() {\n\n    if( this.placeholder !== null\n      && this.placeholder.parentNode !== null ) {\n      this.placeholder.parentNode.removeChild( this.placeholder );\n    }\n  }\n\n  private checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\n\n    if( this.placeholder === null ) {\n\n      return;\n    }\n\n    // make sure the placeholder is in the DOM\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\n\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\n    }\n\n    // update the position if the event originates from a child element of the dropzone\n    const directChild = getDirectChildElement( this.elementRef.nativeElement, event.target as Element );\n\n    // early exit if no direct child or direct child is placeholder\n    if( directChild === null\n      || directChild === this.placeholder ) {\n\n      return;\n    }\n\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\n\n    if( positionPlaceholderBeforeDirectChild ) {\n\n      // do insert before only if necessary\n      if( directChild.previousSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\n      }\n    }\n    else {\n\n      // do insert after only if necessary\n      if( directChild.nextSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\n      }\n    }\n  }\n\n  private getPlaceholderIndex():number | undefined {\n\n    if( this.placeholder === null ) {\n\n      return undefined;\n    }\n\n    const element = this.elementRef.nativeElement as HTMLElement;\n\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\n  }\n\n  private cleanupDragoverState() {\n\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\n\n    this.removePlaceholderFromDOM();\n  }\n}\n","import { Directive, HostBinding, HostListener } from \"@angular/core\";\nimport { DndEvent } from \"./dnd-utils\";\nimport { DndDraggableDirective } from \"./dnd-draggable.directive\";\n\n@Directive( {\n  selector: \"[dndHandle]\"\n} )\nexport class DndHandleDirective {\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  constructor( parent:DndDraggableDirective ) {\n\n    parent.registerDragHandle( this );\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEvent( event:DndEvent ) {\n\n    event._dndUsingHandle = true;\n  }\n}\n","import { NgModule } from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { DndDraggableDirective, DndDragImageRefDirective } from \"./dnd-draggable.directive\";\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from \"./dnd-dropzone.directive\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\n\n@NgModule( {\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ],\n  exports: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ]\n} )\nexport class DndModule {\n}\n"]}